// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['domReady', 'd3', 'jquery', 'modernizr', 'backbone', 'underscore'], function(domReady, d3, $, Modernizr, Backbone, _) {
    var $coord, $nodeInfo, ESCAPE_KEY_CODE, GeometricZoomGraph, Graph, LabelSet, NetX, NodeInfo, Params, Popup, SMOOTHING, getPositionQuery, graph, popup, _ref,
      _this = this;
    Params = {
      NODE_INIT_RANGE: 0.5,
      FORCE_LAYOUT_DECAY: 0.95
    };
    NetX = (function() {
      function NetX() {}

      NetX.LABEL_TICK_MS = 1000;

      NetX.getQueryString = function() {
        var keyValues, queries,
          _this = this;
        queries = window.parent.location.search.replace('?', '').split('&');
        keyValues = {};
        $.each(queries, function(i, kv) {
          var s;
          s = kv.split('=');
          if (2 === s.length) {
            return keyValues[s[0]] = s[1];
          }
        });
        return keyValues;
      };

      NetX.bound = function(val, min, max) {
        return Math.max(min, Math.min(max, val));
      };

      NetX.boxCollision = function(b1, b2) {
        return !(b1.left >= b2.right || b1.top >= b2.bottom || b1.right < b2.left || b1.bottom < b2.top);
      };

      return NetX;

    })();
    /*
    Description and state-holder for a single Graph visualization.
    This is mostly a wrapper around a d3 force layout.
    */

    Graph = (function() {
      function Graph(options) {
        var queries, _ref,
          _this = this;
        _ref = [options.width, options.height], this.width = _ref[0], this.height = _ref[1];
        this.minScale = 0.5;
        this.maxScale = 8;
        this.detailInterval_ = null;
        this.setupSize(this.width, this.height);
        _.bindAll(this, 'tickUpdate', 'getRadiusForNode');
        this.setupSize(this.width, this.height);
        this.xScale = d3.scale.linear().domain([0, this.width]).range([0, 0]);
        this.yScale = d3.scale.linear().domain([0, this.height]).range([0, 0]);
        this.zoomRange = d3.scale.linear().domain([this.minScale, this.maxScale]).rangeRound([this.minScale, this.maxScale]).clamp(true).nice();
        this.zoom = d3.behavior.zoom().x(this.xScale).y(this.yScale).scaleExtent([this.minScale, this.maxScale]).on('zoom', function(e) {
          return _this.tickUpdate(e);
        });
        this.svgContext = d3.select('.graph').append('svg').attr('id', 'visualization').attr('class', 'light').attr('width', this.width).attr('height', this.height).call(this.zoom);
        this.svg = this.svgContext.append('g').attr('id', 'elements').attr('width', this.width).attr('height', this.height);
        this.$svg = this.svg[0][0];
        this.url = options.url;
        this.links = void 0;
        this.nodes = void 0;
        this.labels = void 0;
        this.circles = void 0;
        this.json = void 0;
        this.pointsQuadTree_ = void 0;
        this.nodeInfos = [];
        this.activeNode = null;
        this.targetScale = 1.0;
        this.actualTranslate = [0, 0];
        this.actualScale = this.targetScale;
        this.isZooming = false;
        this.force = d3.layout.force().charge(-300).size([this.width, this.height]).friction(0.6).gravity(0).theta(0.9).linkStrength(0.9).linkDistance(function(o, i) {
          return 20 + (o.source.importance * o.target.importance);
        });
        queries = NetX.getQueryString();
        console.log("queries");
        console.log(queries);
        this.startPositions = this.setupStartPositions(queries);
        console.log("Fixed positions");
        console.log(this.startPositions);
        d3.json(this.url, function(json) {
          _this.json = json;
          $('#graph-loading').html('');
          _this.setupLinks().setupNodes().setuptickUpdate().setupClick().setupHover().setupDrag();
          _this.force.nodes(_this.json.nodes).links(_this.json.links);
          _this.labels = new LabelSet(_this.svg);
          _this.force.nodes().forEach(function(d, i) {
            var fP, node_style, r;
            node_style = d.node_style.split(' ');
            if (i in _this.startPositions) {
              fP = _this.startPositions[i];
              d.x = fP.x;
              d.y = fP.y;
            } else {
              r = Params.NODE_INIT_RANGE;
              d.x = _this.width * ((1.0 - r) * 0.5 + Math.random() * r);
              d.y = _this.height * ((1.0 - r) * 0.5 + Math.random() * r);
            }
            if ($.inArray('fixed', node_style) > -1) {
              d.fixed = true;
              return _this.nodeInfos[i].isFixed = true;
            }
          });
          return _this.force.start();
        });
      }

      _.extend(Graph.prototype, Backbone.Events);

      Graph.prototype.getRadiusForNode = function(d) {
        var importance;
        importance = d.importance || 1;
        return Math.max(5, importance * 2);
      };

      Graph.prototype.setupSize = function(width, height) {
        this.width = width;
        return this.height = height;
      };

      Graph.prototype.setupStartPositions = function(queries) {
        var coordinates, key, nodeID, startPositions, value;
        startPositions = {};
        for (key in queries) {
          value = queries[key];
          nodeID = parseInt(key);
          coordinates = value.split('+');
          if (isNaN(nodeID || 2 !== coordinates.length)) {
            continue;
          }
          startPositions[nodeID] = {
            'x': parseInt(coordinates[0]),
            'y': parseInt(coordinates[1])
          };
        }
        return startPositions;
      };

      Graph.prototype.setupLinks = function() {
        this.links = this.svg.selectAll('.link').data(this.json.links).enter().append('line').attr('class', 'link');
        this.$links = this.links[0];
        return this;
      };

      Graph.prototype.setupNodes = function() {
        var _this = this;
        this.nodes = this.svg.selectAll('g.node').data(this.json.nodes).enter().append('g').attr('id', function(d, i) {
          return 'n' + i;
        }).attr('class', 'node').call(this.force.drag);
        this.nodes.append('circle').attr('r', this.getRadiusForNode).attr('class', function(d) {
          return 'node-circle ' + d.node_style || '';
        });
        this.nodes.append('g').attr('id', function(d, i) {
          return 'l' + i;
        }).attr('class', function(d) {
          return 'label ' + d.label_style || '';
        });
        this.circles = this.svg.selectAll('g.node circle');
        this.nodes.each(function(d, i) {
          return _this.nodeInfos.push(new NodeInfo(d, i));
        });
        return this;
      };

      Graph.prototype.setuptickUpdate = function() {
        var _this = this;
        this.force.on('tick', function(e) {
          return _this.tickUpdate(e);
        });
        return this;
      };

      Graph.prototype.setupClick = function() {
        var _this = this;
        this.svg.selectAll('g.node').on('click', function(d) {
          return _this.trigger('click:node', d3.event, d);
        });
        this.svg.selectAll('g.label').on('click', function(d) {
          return _this.trigger('click:node', d3.event, d);
        });
        return this;
      };

      Graph.prototype.setupHover = function() {
        var _this = this;
        this.json.links.forEach(function(edge, index) {
          _this.nodeInfos[edge.source].addLinkMapping(_this.$links[index]);
          return _this.nodeInfos[edge.target].addLinkMapping(_this.$links[index]);
        });
        this.nodeInfos.forEach(function(n) {
          return n.cacheLinks();
        });
        this.svg.selectAll('g.node').on('mouseover', function(d, i) {
          return _this.hover(d, i, true);
        }).on('mouseout', function(d, i) {
          return _this.hover(d, i, false);
        });
        return this;
      };

      Graph.prototype.setupDrag = function() {
        var drag, listenerFactory,
          _this = this;
        drag = this.force.drag();
        listenerFactory = function(beingDragged) {
          return function(d, i) {
            var label, node;
            label = d3.select('#l' + i);
            label.classed('drag-label', beingDragged);
            node = d3.select('#n' + i);
            label.classed('drag-node', beingDragged);
            if (beingDragged) {
              _this.hover(d, i, true);
            }
            _this.dragging = beingDragged;
            if (!beingDragged) {
              return _this.hover(d, i, false);
            }
          };
        };
        drag.on('dragstart.label-highlight', listenerFactory(true));
        drag.on('dragend.label-highlight', listenerFactory(false));
        return this;
      };

      Graph.prototype.getPositionQuery = function() {
        return this.nodeInfos.filter(function(n) {
          return n.isFixed;
        }).map(function(n) {
          return n.getPositionQuery();
        }).join('&');
      };

      Graph.prototype.hover = function(d, i, hover) {
        if (this.dragging) {
          return false;
        }
        if (!hover && null !== this.activeNode) {
          this.activeNode.deactivate();
          this.activeNode = null;
        }
        if (hover) {
          this.activeNode = this.nodeInfos[i];
          return this.activeNode.activate();
        }
      };

      return Graph;

    })();
    /*
    Keep track of details for a single Node, for activeNode and dragging
    interacitons.
    */

    NodeInfo = (function() {
      NodeInfo.ROUNDING_POINT = 4;

      function NodeInfo(data, id) {
        this.data = data;
        this.id = id;
        this.label = d3.select('#l' + this.id);
        this.node = d3.select('#n' + this.id);
        this.links = [];
        this.sLinks = null;
        this.isFixed = false;
      }

      NodeInfo.prototype.addLinkMapping = function($link) {
        return this.links.push($link);
      };

      NodeInfo.prototype.cacheLinks = function() {
        return this.sLinks = d3.selectAll(this.links);
      };

      NodeInfo.prototype.activate = function() {
        this.label.classed('hidden', false);
        this.label.classed('hovered-label', true);
        this.node.classed('hovered-node', true);
        return this.sLinks.classed('hover', true);
      };

      NodeInfo.prototype.deactivate = function() {
        this.label.classed('hovered-label', false);
        this.node.classed('hovered-node', false);
        return this.sLinks.classed('hover', false);
      };

      NodeInfo.prototype.getPositionHtml = function() {
        return 'X: ' + this.data.x.toFixed(this.ROUNDING_POINT) + '<br>Y: ' + this.data.y.toFixed(this.ROUNDING_POINT);
      };

      NodeInfo.prototype.getPositionQuery = function() {
        return this.id + '=' + this.data.x.toFixed(this.ROUNDING_POINT) + '+' + this.data.y.toFixed(this.ROUNDING_POINT);
      };

      return NodeInfo;

    })();
    SMOOTHING = {
      ENABLED: true,
      MAX_INVERT: 1.25
    };
    /*
    Description of a set of labels on nodes, primarily in order to determine
    visibility and bounds checking.
    */

    LabelSet = (function() {
      function LabelSet(svg) {
        var _this = this;
        this.labels = svg.selectAll('g.label').append('text').attr('class', function(d) {
          return 'label-text ' + (d.label_style || '');
        }).attr('text-anchor', 'middle').text(function(d) {
          return d.name;
        });
        this.total = this.labels[0].length;
        this.selections = [];
        this.$labels = [];
        this.labels.each(function(d, i) {
          _this.$labels.push(_this.labels[0][i]);
          return _this.selections.push(d3.select(_this.$labels[i]));
        });
        this.labelClashTimerID_ = null;
      }

      LabelSet.prototype.checkVisibility = function(el) {
        var has;
        has = function(s) {
          return el.classed(s);
        };
        if ((has('always-shown-label')) || (has('hovered-label')) || (has('drag-label'))) {
          return true;
        }
        if (has('always-hidden-label')) {
          return false;
        }
        return null;
      };

      LabelSet.prototype.isObscured = function(d, i) {
        var d2, j, s, _i, _len, _ref;
        _ref = this.selections;
        for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
          s = _ref[j];
          d2 = s.datum();
          if ((j !== i) && (true === d2.isVisible) && NetX.boxCollision(d.label_bounds, d2.label_bounds)) {
            return true;
          }
        }
        return false;
      };

      LabelSet.prototype.tickUpdate = function(e) {
        var ticks,
          _this = this;
        ticks = 5;
        if (null === this.labelClashTimerID_) {
          return this.labelClashTimerID_ = window.setInterval(function() {
            var sLabel;
            sLabel = null;
            _this.labels.each(function(d, i) {
              d.label_bounds = _this.$labels[i].getBoundingClientRect();
              return d.isVisible = _this.checkVisibility(_this.selections[i]);
            });
            _this.labels.each(function(d, i) {
              sLabel = _this.selections[i];
              if (null === d.isVisible) {
                d.isVisible = !_this.isObscured(d, i);
              }
              return sLabel.classed('hidden', !d.isVisible);
            });
            if (ticks-- <= 0) {
              clearInterval(_this.labelClashTimerID_);
              return _this.labelClashTimerID_ = null;
            }
          }, NetX.LABEL_TICK_MS);
        }
      };

      LabelSet.prototype.transform = function(invertScale) {
        var _this = this;
        return this.labels.transition().call(GeometricZoomGraph.smooth, this.isZooming).attr('transform', function(d) {
          var voffset;
          if (void 0 === d || void 0 === d.label_bounds) {
            return;
          }
          voffset = 0;
          if (void 0 === d.short_description || '' === d.short_description) {
            voffset = (d.label_bounds.bottom - d.label_bounds.top) * 0.3 * invertScale;
          } else {
            voffset = Graph.prototype.getRadiusForNode(d) + (d.label_bounds.bottom - d.label_bounds.top) * 0.9;
          }
          return 'translate(0, ' + voffset * invertScale + ')' + 'scale(' + invertScale + ')';
        });
      };

      return LabelSet;

    })();
    /*
    Zoomable graph.
    */

    GeometricZoomGraph = (function(_super) {
      __extends(GeometricZoomGraph, _super);

      function GeometricZoomGraph() {
        _ref = GeometricZoomGraph.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      GeometricZoomGraph.smooth = function(transition, isZooming) {
        var algorithm, trans_ms;
        trans_ms = isZooming ? 231 : 33;
        algorithm = isZooming ? 'easeInOutQuad' : 'easeInOutSine';
        transition.duration(trans_ms).ease(algorithm);
        return transition;
      };

      GeometricZoomGraph.prototype.tick = 1;

      GeometricZoomGraph.prototype.tickUpdate = function(e) {
        var alpha, box, invertFactor, invertScale, rawCenterX, rawCenterY, scale, tX, tXmin, tY, tYmin, transformVal, translate;
        if (this.labels) {
          this.labels.tickUpdate(e);
        }
        translate = this.zoom.translate();
        scale = this.zoom.scale();
        box = this.$svg.getBBox();
        rawCenterX = box.x + box.width / 2;
        rawCenterY = box.y + box.height / 2;
        tXmin = -(rawCenterX * scale);
        tYmin = -(rawCenterY * scale);
        tX = NetX.bound(translate[0], tXmin, this.width + tXmin);
        tY = NetX.bound(translate[1], tYmin, this.height + tYmin);
        translate = [tX, tY];
        this.zoom.translate(translate);
        if (SMOOTHING.ENABLED) {
          this.targetScale = scale;
          if (!this.isZooming) {
            this.isZooming = scale !== this.actualScale;
          }
          this.svg.transition().call(GeometricZoomGraph.smooth, this.isZooming).attr('transform', 'translate(' + translate + ')' + 'scale(' + scale + ')').each('end', function() {
            return this.isZooming = false;
          });
          if (this.isZooming) {
            if (this.circles) {
              invertFactor = 0.8;
              invertScale = (invertFactor / this.targetScale) + (1 - invertFactor);
              invertScale = Math.min(SMOOTHING.MAX_INVERT, invertScale);
              transformVal = 'scale(' + invertScale + ')';
              this.circles.transition().call(GeometricZoomGraph.smooth, this.isZooming).attr('transform', transformVal);
            }
            this.links.transition().call(GeometricZoomGraph.smooth, this.isZooming).style('stroke-width', 1 / this.targetScale);
          }
        } else {
          this.svg.attr('transform', 'translate(' + translate + ')' + 'scale(' + scale + ')');
        }
        if (this.labels) {
          this.labels.transform(1.0 / this.targetScale);
        }
        this.actualScale = scale;
        this.actualTranslate = translate;
        this.nodes.attr('transform', function(d) {
          return 'translate(' + d.x + ',' + d.y + ')';
        });
        this.links.attr('x1', function(d) {
          return d.source.x;
        }).attr('y1', function(d) {
          return d.source.y;
        }).attr('x2', function(d) {
          return d.target.x;
        }).attr('y2', function(d) {
          return d.target.y;
        });
        alpha = this.force.alpha();
        if (alpha < 0.09) {
          return this.force.alpha(alpha * Params.FORCE_LAYOUT_DECAY);
        }
      };

      return GeometricZoomGraph;

    })(Graph);
    /*
    Description of the popup details for every node.
    */

    Popup = (function() {
      function Popup(options) {
        _.bindAll(this, 'open', 'close');
        this.$el = $('.info-panel');
        this.$heading = this.$el.find('.info-heading');
        this.$shortDescription = this.$el.find('.info-short-description');
        this.$longDescription = this.$el.find('.info-long-description');
        this.$youtube = this.$el.find('.info-youtube');
        this.$link = this.$el.find('.more-information-link');
        this.$credit = this.$el.find('.info-credit');
        this.currentCoords = {
          x: void 0,
          y: void 0
        };
        this.data = {
          heading: '',
          shortDescription: '',
          longDescription: '',
          youtube: '',
          contextUrl: '',
          credit: ''
        };
        this.panelOpen = false;
        this.transitionPrefixedName = this.hyphenisor(Modernizr.prefixed('transition'));
        this.transformPrefixedName = this.hyphenisor(Modernizr.prefixed('transform'));
        this.setupCloseEvent();
      }

      _.extend(Popup.prototype, Backbone.Events);

      Popup.prototype.hyphenisor = function(str) {
        return str.replace(/([A-Z])/g, function(str, letter) {
          return '-' + letter.toLowerCase();
        }).replace(/^ms-/, '-ms-');
      };

      Popup.prototype.open = function(coords) {
        var css,
          _this = this;
        if (!this.panelOpen) {
          css = {
            top: coords.y + 'px',
            left: coords.x + 'px'
          };
          css[this.transitionPrefixedName] = 'none';
          this.$el.css(css);
          window.setTimeout(function() {
            css = {
              opacity: 1,
              top: '',
              left: '50%'
            };
            css[_this.transformPrefixedName] = 'scale(1)';
            css[_this.transitionPrefixedName] = 'all 0.2s';
            return _this.$el.css(css);
          }, 0);
          this.panelOpen = true;
        }
        return this.currentCoords = coords;
      };

      Popup.prototype.close = function() {
        var css;
        css = {
          opacity: 0,
          top: this.currentCoords.y + 'px',
          left: this.currentCoords.x + 'px'
        };
        css[this.transformPrefixedName] = 'scale(0)';
        this.$el.css(css);
        return this.panelOpen = false;
      };

      Popup.prototype.setupCloseEvent = function() {
        return this.$el.on('click', '.close-button', this.close);
      };

      Popup.prototype.setData = function(data) {
        return this.data = data;
      };

      Popup.prototype.renderContent = function() {
        this.$heading.text(this.data.heading);
        this.$shortDescription.text(this.data.shortDescription);
        this.$longDescription.text(this.data.longDescription);
        this.$youtube.html(this.data.youtube);
        this.$credit.html(this.data.credit);
        if (this.data.contextUrl) {
          this.$link.toggle(true);
          return this.$link.attr('href', this.data.contextUrl);
        } else {
          this.$link.toggle(false);
          return this.$link.attr('href', '');
        }
      };

      return Popup;

    })();
    getPositionQuery = function() {
      return console.log('wtf');
    };
    $ - (graph = new GeometricZoomGraph({
      width: window.innerWidth,
      height: window.innerHeight,
      url: $('body').data('graph-url')
    }));
    window.getPositionQuery = function() {
      return graph.getPositionQuery();
    };
    popup = new Popup();
    ESCAPE_KEY_CODE = 27;
    popup.listenTo(graph, 'click:node', function(evt, obj) {
      var context_url, credit, youtube_id;
      if (void 0 === obj.short_description) {
        return;
      }
      credit = obj.credit;
      youtube_id = obj.youtube_id;
      context_url = obj.context_url;
      popup.open({
        x: evt.offsetX,
        y: evt.offsetY - 175
      });
      if (0 === credit.indexOf('http://')) {
        credit = '<a href="' + credit + 'target="_blank">' + credit + '</a>';
      }
      if (credit) {
        credit = "This data entry was provided by " + credit;
      }
      if (youtube_id) {
        youtube_id = '<iframe title="YouTube video player" ' + 'src="http://www.youtube.com/embed/' + youtube_id + '" width="480" height="390" frameborder="0"></iframe>';
        context_url = '';
      }
      popup.setData({
        heading: obj.name,
        shortDescription: obj.short_description,
        longDescription: obj.long_description,
        contextUrl: context_url,
        credit: credit,
        youtube: youtube_id
      });
      return popup.renderContent();
    });
    $('body').on('click', function(evt) {
      if ((0 === $(evt.target).closest('.info-panel').length) && (!$(evt.target).is('.circle'))) {
        return popup.close();
      }
    });
    $('body').on('keydown', function(evt) {
      if (ESCAPE_KEY_CODE === evt.keyCode) {
        return popup.close();
      }
    });
    window.onresize = function(e) {
      return graph.setupSize(window.innerWidth, window.innerHeight);
    };
    $nodeInfo = $('#node-info');
    $coord = $('#graph-coordinates');
    return $(document).mousemove(function(e) {
      if (graph.activeNode) {
        $nodeInfo.show();
        $nodeInfo.removeClass('hidden');
        $coord.html(graph.activeNode.getPositionHtml());
        return $nodeInfo.css({
          left: e.clientX,
          top: e.clientY
        });
      } else {
        $nodeInfo.addClass('hidden');
        return window.setTimeout((function() {
          return $nodeInfo.hide();
        }), 100);
      }
    });
  });

}).call(this);
